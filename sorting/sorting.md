정렬 Sorting
===

> 데이터를 일정한 순서대로 배열하는 알고리즘  
> 다양한 알고리즘의 선행 작업으로 사용하는 경우가 많다.

<br>

## 참고

정렬 알고리즘은 다양한 방법이 제시되어 있다. 각각의 방법이 가지는 장단점이 서로 다르기 때문에 적절한 알고리즘의 사용이 중요하다.

`C++` 나 `Rust` 를 비롯해 대다수 언어에서는 `sort` 함수를 제공한다. 이러한 함수는 고성능의 정렬 알고리즘을 사용하고 있기 때문에 특별한 이유가 있지 않다면 기본 제공 함수를 쓰는 것이 좋다.

<br>

## 종류

### 버블 정렬 (Bubble Sort)

인접한 두 요소를 비교해 작은 수를 앞으로 보내는 작업을 반복하며 정렬한다.

<br>

**장점**: 구현이 간단하고 직관적이다.

**단점**: 정렬 시간이 오래 걸린다.

<br>

#### 과정

알고리즘의 세부적인 과정은 다음과 같다.

1. 배열의 맨 앞 요소부터 정렬되지 않은 배열의 마지막까지 교환 작업을 진행한다.
   1. 현재 요소가 다음 요소보다 크다면 교환한다.
   2. 다음 칸으로 이동한다.
2. 정렬이 완료될 때까지 이를 반복한다.

<br>

  * 시간 복잡도: O(n²)
  * 공간 복잡도: O(1)

<br>

> 코드    [`C++`]() [`Rust`]()

***

### 선택 정렬 (Selection Sort)

정렬되지 않은 요소 중 가장 작은 것을 찾아 차례대로 붙이며 정렬한다.

<br>

**장점**: 구현이 간단하고 직관적이다.

**단점**: 정렬 시간이 오래 걸린다.

<br>

#### 과정

알고리즘의 세부적인 과정은 다음과 같다.

1. 정렬되지 않은 부분에서 가장 작은 요소를 찾는다.
2. 찾은 요소와 정렬되지 않은 부분의 맨 앞 요소를 교환하여 찾은 요소를 정렬된 배열에 추가한다.
3. 정렬이 완료될 때까지 이를 반복한다.

<br>

  * 시간 복잡도: O(n²)
  * 공간 복잡도: O(1)

<br>

> 코드    [`C++`]() [`Rust`]()

***

### 삽입 정렬 (Insertion Sort)

정렬이 이루어지지 않은 배열의 요소를 이미 정렬된 배열의 적합한 위치에 삽입하며 정렬한다.

동작이 간단해 **작은 크기의 배열에서 효율적**이다. 재귀적으로 정렬하는 방법을 사용할 때 배열 크기가 충분히 작아지면 삽입 정렬을 사용하는 방법으로 최적화하는 경우가 있다.

비교 비용이 큰 데이터를 정렬하는 경우, 이진 탐색을 사용해 삽입 위치를 찾기 위한 비교를 줄일 수 있다. 이러한 변형을 **이진 삽입 정렬**이라고 한다.

<br>

**장점**: 구현이 간단하고 직관적이다. 배열 크기가 작다면 좋은 성능을 보인다.

**단점**: 정렬 시간이 오래 걸린다.

<br>

#### 과정

알고리즘의 세부적인 과정은 다음과 같다.

1. 정렬되지 않은 부분의 맨 앞 요소를 선택한다.
2. 선택한 요소를 정렬된 배열의 적합한 위치에 삽입한다.
   1. 선택한 요소의 앞부터 선택한 요소보다 크면 뒤로 민다.
   2. (1)의 반복이 끝나면 끝난 위치 다음 칸에 선택한 요소 값을 넣는다.
3. 정렬이 완료될 때까지 이를 반복한다.

<br>

  * 시간 복잡도: O(n²)
  * 공간 복잡도: O(1)

<br>

> 코드    [`C++`]() [`Rust`]()

> 관련한 내용    [`이진탐색`]()

***

### 퀵 정렬 (Quick Sort)

배열에서 피벗(수행을 위한 임의의 요소)을 선정한 후, 피벗을 기준으로 피벗보다 작은 값의 배열과 피벗보다 큰 값의 배열로 나누어 각각을 재귀적으로 정렬하고 합하는 방법으로 정렬한다.

퀵 정렬은 **매우 빠른 정렬 알고리즘**이지만 **최악의 경우**일 때 **O(n²)** 의 복잡도를 가지게 되므로 주의해서 사용해야 한다.

<br>

**장점**: 배열을 빠르게 정렬한다.

**단점**: 편향된 값을 가지는 요소가 피벗으로 선정되면 배열이 불균형하게 분할되어 O(n²)의 복잡도를 가지게 될 수 있다.

<br>

#### 과정

알고리즘의 세부적인 과정은 다음과 같다.

1. 배열의 길이가 2보다 작다면 중단한다. (재귀의 탈출 조건)
2. 피벗을 선정한다.
3. 피벗을 기준으로 작은 값은 피벗의 왼쪽으로, 큰 값은 피벗의 오른쪽으로 분할한다.
   1. 왼쪽에서 피벗보다 큰 요소를 찾고, 오른쪽에서 피벗보다 작은 요소를 찾아 교환한다.
   2. (1)의 작업을 왼쪽 포인터가 오른쪽 포인터의 오른쪽에 올 때까지 반복한다.
   3. 피벗과 오른쪽 포인터가 가리키는 요소와 교환한다.
4. 나누어진 배열을 재귀적으로 정렬한다.

<br>

* 시간 복잡도:
    * 평균: O(n log n)
    * 최악: O(n²)
* 공간 복잡도:
  * 평균: O(log n)
  * 최악: O(n)

<br>


> 코드    [`C++`]() [`Rust`]()

> 관련한 내용    [`분할정복`]()

***

### 합병 정렬 (Merge Sort)

배열을 반으로 쪼개 각각을 정렬하고 다시 합치는 방법으로 정렬한다.

**빠른 정렬 알고리즘**이며, 동일한 순위를 가지는 요소 간의 초기 순서가 보장되는 **안정 정렬**이다. 

이 방법과 삽입 정렬을 기반으로 구현한, **팀 정렬 (Tim Sort)** 이 있다. 팀 정렬은  `Python`을 비롯한 다양한 언어의 표준 정렬 알고리즘이다.

<br>

**장점**: 배열을 안정적이고 효율적으로 정렬한다.

**단점**: 배열을 합치는 과정에서 **추가적인 메모리 공간이 필요**하다.

<br>

#### 과정

알고리즘의 세부적인 과정은 다음과 같다.

1. 배열의 길이가 2보다 작다면 중단한다. (재귀의 탈출 조건)
2. 배열을 반으로 나눈 후 각각을 재귀적으로 정렬한다.
3. 나누었던 배열을 하나로 합친다.
   1. 정렬한 각각의 배열의 앞 부분을 비교한 후 앞서는 요소를 새 배열로 옮긴다.
   2. 선택한 요소를 제외한 후 (1)을 모든 요소에 대해 진행한다.

<br>

  * 시간 복잡도: O(n log n)
  * 공간 복잡도: O(n)

<br>

> 코드    [`C++`]() [`Rust`]()

> 관련한 내용    [`분할정복`]()

***

### 힙 정렬 (Heap Sort)

**힙 구조를 이용**해 배열을 정렬한다. 배열을 힙 구조로 구성하고, 힙의 루트를 추출하여 배열의 끝에 삽입하는 방식으로 동작한다.

**효율적인 정렬 알고리즘**이며, 추가적인 메모리 사용이 없는 **제자리 정렬**이다.

<br>

**장점**: 추가 메모리를 요구하지 않으며, 효율적으로 정렬한다.

**단점**: **힙 구조를 구성**하는 단계로 인해 **추가적인 연산**이 발생한다.

<br>

#### 과정

알고리즘의 세부적인 과정은 다음과 같다.

1. 배열을 최대 힙 구조로 만든다.
2. 힙의 루트를 추출한 후 배열의 끝에 삽입한다.
   1. 이를 힙의 크기가 1이 될 때까지 반복한다.

<br>


  * 시간 복잡도: O(n log n)
  * 공간 복잡도: O(1)

<br>

> 코드    [`C++`]() [`Rust`]()

> 관련한 내용    [`힙`]()

***

### 계수 정렬 (Counting Sort)

**데이터**가 **정수**, 혹은 정수로 표현 가능할 때 사용 가능한 **특수한 정렬 방법**이다. 각 요소의 개수를 세어 계수 배열에 저장하고 계수 배열의 누적 합을 계산한 후 각 요소의 위치를 구하며 정렬한다.

요소 간 비교가 이루어지지 않는다는 특징이 있다.

계수 배열은 데이터 범위에 의해 크기가 결정된다. 따라서 데이터의 범위가 제한되어 있거나 최솟값과 최댓값이 주어져야 한다.

**데이터 범위가 좁을수록 효율적**으로 정렬할 수 있다.

계수 정렬을 동작의 일부로 사용하는 **기수 정렬 (Radix Sort)** 이 있다.

<br>

**장점**: 데이터 조건만 충족하면 매우 빠르게 정렬이 가능하다.

**단점**: 정수 표현이 불가능하거나 데이터 범위가 넓은 경우 사용할 수 없다.

<br>

#### 과정

알고리즘의 세부적인 과정은 다음과 같다.

1. 배열을 순회하며 계수 배열에 요소의 개수를 저장한다.
2. 계수 배열의 누적 합을 구한다.
3. 배열을 역순으로 순회하며 각 요소의 위치를 구해 결과 배열에 넣는다.
   1. 계수 배열 값을 1 감소시킨다.
   2. 현재 요소에 해당하는 계수 배열 값의 번호 칸의 결과 배열에 현재 요소를 넣는다.

<br>

* 시간 복잡도: O(n+k)
* 공간 복잡도: O(n+k)

`n: 배열의 크기`  `k: 데이터의 범위`

<br>

> 코드    [`C++`]() [`Rust`]()

> 관련한 내용    [`누적합`]()
